# 欧几里得算法

1. 欧几里得算法可以求解 a,b 两数的最大公约数，时间复杂度为 $O(\log(max(a,b)))$ ，递归实现一般不会栈溢出。用欧几里得算法去求斐波那契数列相邻两项的最大公约数，该算法会达到最坏复杂度。
2. 如果要求多个数的最大公约数（最小公倍数），当我们算出两个数的最大公约数（最小公倍数）之后，将它放入序列中对后面的数继续求解即可。
3. a,b,c 为任意整数，扩展欧几里得算法可以求解方程 $ax+by=gcd(a,b)$ 的一组整数解。
   1. 调用扩展欧几里得算法时，需保证 a,b 为正整数。
   2. 若方程 $ax+by=c$ 的一组整数解为 $(x_0,y_0)$ ，，则它的任意整数解都可以写成 $(x_0+kb', y_0-ka')$ ，其中 $a'=a/gcd(a,b)$ ， $b'=b/gcd(a,b)$ ，k 取任意整数。
   3. 若 $g=gcd(a,b)$ ，方程 $ax+by=g$ 的一组解是 $(x_0,y_0)$ ，则当 c 是 g 的倍数时， $ax+by=c$ 的一组解是 $(cx_0/g, cy_0/g)$ ；当 c 不是 g 的倍数时无整数解。

## 通过欧几里得算法计算两个正整数的最大公约数

```cpp
gg gcd(gg a, gg b) { return b == 0 ? a : gcd(b, a % b); }
```

## 扩展欧几里得算法求解方程 ax+by=gcd(a,b)的一组整数解，并返回 gcd(a,b)的值

```cpp
//返回{gcd(a,b),x,y}，x,y是方程ax+by=gcd(a,b)的一组解
array<gg, 3> extendGcd(gg a, gg b) {
    if (b == 0) {
        return {a, 1, 0};
    }
    auto d = extendGcd(b, a % b);
    return {d[0], d[2], d[1] - (a / b) * d[2]};
}
//返回方程ax+by=c的解中x的最小非负整数值
gg getMinX(gg a, gg b, gg c) {
    auto d = extendGcd(a, b);
    return (c / d[0] * d[1] % (b / d[0]) + b / d[0]) % (b / d[0]);
}
```
