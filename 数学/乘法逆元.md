# 乘法逆元

如果一个线性同余方程 $ax\equiv 1(mod\ n)$ ，则 $x$ 称为 $a\ mod\ n$ 的逆元，记作 $a^{-1}$ 。

## 扩展欧几里得算法求逆元

若 $gcd(a,n)\not ={1}$ ，则方程无解。所以如果方程有解的话，就可以通过[扩展欧几里得算法](./欧几里得算法.md)求逆元。

## 快速幂法求逆元

根据费马小定理，若 $n$ 为素数，且 $gcd(a,n)=1$ ， $a\ mod\ n$ 的逆元可以计算为 $a^{n-2}$ ，可通过[快速幂](./快速幂.md)求解。

## 求 $1,2,\cdots,n$ 中每个数关于 $p$ 的逆元

算法时间复杂度为 $O(n)$ 。

```cpp
gg inv[MAX];
void invEle(gg n, gg p) {
    inv[1] = 1;
    for (gg i = 2; i <= n; ++i) {
        inv[i] = (p - p / i) * inv[p % i] % p;
    }
}
```

## 求任意 $n$ 个数关于 $p$ 的逆元

首先计算 n 个数的前缀积，记为 $s_i$ ，然后利用快速幂或扩展欧几里得算法计算 $s_n$ 的逆元，记作 $sv_n$ 。因为 $sv_n$ 是 n 个数的积的逆元，所以当我们把它乘上 $a_n$ 时，就会和 $a_n$ 的逆元抵消，于是就得到了 $a_1$ 到 $a_n$ 的积逆元，记为 $sv_{n-1}$ 。可以依次计算出所有的 $sv_i$ ，于是 $a_i^{-1}$ 就可以用 $s_{i-1}\cdot sv_i$ 求得。算法时间复杂度为 $O(n+log\ p)$

```cpp
gg inv[MAX], s[MAX], a[MAX], sv[MAX];
void invEle(gg n, gg p) {
    s[0] = 1;
    for (gg i = 1; i <= n; ++i) {
        s[i] = s[i - 1] * a[i] % p;
    }
    //也可以用扩展欧几里得来求逆元,视个人喜好而定.
    sv[n] = powMod(s[n], p - 2, p);
    for (gg i = n; i >= 1; --i) {
        sv[i - 1] = sv[i] * a[i] % p;
    }
    for (gg i = 1; i <= n; ++i) {
        inv[i] = sv[i] * s[i - 1] % p;
    }
}
```
