# 素数

## 用暴力方法判断 n 是否为素数

算法的时间复杂度为$O(\sqrt n)$

```cpp
bool isPrime(gg n) {
    if (n < 2) {  // n 小于 2，一定不是素数
        return false;
    }
    for (gg i = 2; i <= (gg)sqrt(n); ++i) {  //遍历 2~根号 n 所有的数
        if (n % i == 0) {  // n 能被 i 整除，说明 n 不是素数
            return false;
        }
    }
    return true;  // n 不能被 2~n 任何数整除，则 n 是素数
}
```

## 用埃氏筛法求解 [2,n) 以内的素数表

算法的时间复杂度为$O(nloglogn)$

```cpp
vector<gg> prime;  //素数表存储在 prime 中，prime 是全局变量
void getPrime(gg n = 1e6) {
    // f[i] 为 true，表示数字 i 被筛去了；如果 f[i] 为 false，表示数字i没有被筛去
    bool f[n + 5]{};
    for (gg i = 2; i < n; ++i){
        if (not f[i]) {  // i 没有被筛去
            prime.push_back(i);
            for (gg j = i + i; j < n; j += i)  //筛去 i 的所有倍数
                f[j] = true;
        }
    }
}
```

## 用欧拉筛法求解 [2,n) 以内的素数表

算法的时间复杂度为$O(n)$

```cpp
vector<gg> prime;  //素数表存储在prime中，prime是全局变量
void getPrime(gg n = 1e6) {
    bool f[n + 5]{};  // i为素数，则f[i]=true;i不是素数，则f[i]=false
    for (gg i = 2; i < n; ++i) {
        if (not f[i]) {
            prime.push_back(i);
        }
        for (gg j = 0; j < prime.size() and i * prime[j] < n; ++j) {
            f[i * prime[j]] = true;
            if (i % prime[j] == 0)  //关键
                break;
        }
    }
}
```

## 利用埃氏筛法求解 [2,n) 以内的所有数字的质因子及其个数

算法的时间复杂度为$O(nlognloglogn)$

```cpp
// prime[i]存储i的质因子，键表示质因子，值表示该质因子个数
map<gg, gg> prime[MAX];
void getPrime(gg n = 1e6) {
    for (gg i = 2; i < n; ++i) {
        if (prime[i].empty()) {  // i 没有被筛去
            prime[i].insert({i, 1ll});
            for (gg j = i + i; j < n; j += i) {
                for (gg k = j; k % i == 0; k /= i) {
                    prime[j][i]++;
                }
            }
        }
    }
}
```
